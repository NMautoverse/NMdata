% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMdata_utils.R
\name{NMisNumeric}
\alias{NMisNumeric}
\title{Determine as.fun to use based on argument and options}
\usage{
NMisNumeric(x)
}
\arguments{
\item{x}{The vector to check Don't export}

\item{data}{Dataset to possibly convert.}

\item{as.fun}{A function to apply if not NULL.}

\item{file.lst}{Path to output control stream.}

\item{file.mod}{Path or function. Default is NULL. See details.}
}
\value{
Possibly converted data.

path to .mod file
}
\description{
Nonmem can only interpret numeric data. However, a
    factor or a character variable may very well be interpretable
    by Nonmem (e.g. "33"). This function tells whether Nonmem will
    be able to read it.
}
\details{
NMdata functions can return objects based on different
    classes. The general default is to return
    data.frames. However, if you prefer working with with other
    classes (typically data.table or tibble), you can have those
    returned instead. In general this is controlled by the run.as
    arguments to functions and the "NMdata.as.fun" option.

You can use the following values for run.as (argument) and
NMdata.as.fun (option):

\itemize{
\item{"none"}{Return a data.table. Yes, a data.table and
 not a data.frame. If you work with data.table, this will give the
 best performance.}
\item{a function}{Apply the function. You
 must supply the actual function, not a string representing
 it. Examples: as.data.frame or tibble::as_tibble. Do not use
 as.data.table - use "none" to get a data.table.}
\item{NULL}{Use default, i.e. try getOptions("NMdata.as.fun") and if still NULL, rely on default behavior.}
}

It is perfectly possible but not recommended to convert the
    results coming out of NMdata functions for three reasons

\itemize{
\item{Convenience}{You would lose the NMdata class which enables a method like summary to work properly.}
\item{Reliability}{You would have to do it every time you have called an NMdata function increasing risk of errors.}
\item{Performance}{can be significantly better using "none".}
} 

The functions that return table data structures (like a data.frame)
    take an argument as.fun which controls this behaviour. You can
    also control the default behaviour by the NMdata.as.fun
    option. If not NULL (the default value) as.fun always
    overrules getOption("NMdata.run.as").

For functions that read and process data from the file system
(like NMreadCsv, NMscanData, NMscanTables and many others),
default is data.frame. Default can be overruled using
options(NMdata.run.as=...), and the default behaviour can be
overruled using the run.as argument.

For functions that process a data set supplied in an argument (as
    opposed to reading data from the file system), the class of
    the input data makes a difference. This applies to functions
    like mergeCheck, NMorderCols, findCovs, findVars, flagsAssign,
    flagsCount. If a data.table is supplied to these (and as.fun
    is NULL), a data.table will be returned. If not, a data.frame
    is still default, and the default can be configured using
    options(NMdata.run.as=...).

NMdata heavily uses data.table under the hood, so "none" means
that no conversion is done by the end of the function. Since
NMdata has no other dependencies than data.table, it cannot
convert to other classes unless the user supply the conversion
function.

NMdata needs the input control stream to find the path to
    the input data file. You have a few different options.
    \itemize{
\item{PSN style}{By default, NMdata assumes that
    by stripping the extension from the output control stream and
    appending .mod, it will find the input control stream.}
\item{path}{file.mod="path/to/input/control/strem"}
\item{translation function}{file.path can be a function that takes the lst path as argument and returns the input control stream path.}
\item{set option}{If you use a function, you may want to set this as default behaviour. Say your output control stream is always called input.txt and located in the same dir as the output control stream, you can use
options(NMdata.file.mod=function(file) file.path(dirname(file),"input.txt"))
}
}

Notice, if the argument dir.data is used in NMscanData or
NMtscanInput, the input control stream is not used at all.
Test if a variable can be interpreted by Nonmem
}
\examples{
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"))
class(dat)
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"),
                  as.fun="none")
class(dat)
options(NMdata.run.as="none")
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"))
class(dat)
library(tibble)
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"),
                  as.fun=tibble::as_tibble)
class(dat)
Determine file.mod to use based on argument and options
}
