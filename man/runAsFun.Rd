% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMdata_utils.R
\name{runAsFun}
\alias{runAsFun}
\title{Determine as.fun to use based on argument and options}
\usage{
runAsFun(data, as.fun)
}
\arguments{
\item{data}{Dataset to possibly convert.}

\item{as.fun}{A function to apply if not NULL.}
}
\value{
Possibly converted data.
}
\description{
Determine as.fun to use based on argument and options
}
\details{
NMdata functions can return objects based on different
    classes. The general default is to return
    data.frames. However, if you prefer working with with other
    classes (typically data.table or tibble), you can have those
    returned instead. In general this is controlled by the run.as
    arguments to functions and the "NMdata.as.fun" option.

You can use the following values for run.as (argument) and
NMdata.as.fun (option):

\itemize{
\item{"none"}{Return a data.table. Yes, a data.table and
 not a data.frame. If you work with data.table, this will give the
 best performance.}
\item{a function}{Apply the function. You
 must supply the actual function, not a string representing
 it. Examples: as.data.frame or tibble::as_tibble. Do not use
 as.data.table - use "none" to get a data.table.}
\item{NULL}{Use default, i.e. try getOptions("NMdata.as.fun") and if still NULL, rely on default behavior.}
}

It is perfectly possible but not recommended to convert the
    results coming out of NMdata functions for three reasons

\itemize{
\item{Convenience}{You would lose the NMdata class which enables a method like summary to work properly.}
\item{Reliability}{You would have to do it every time you have called an NMdata function increasing risk of errors.}
\item{Performance}{can be significantly better using "none".}
} 

The functions that return table data structures (like a data.frame)
    take an argument as.fun which controls this behaviour. You can
    also control the default behaviour by the NMdata.as.fun
    option. If not NULL (the default value) as.fun always
    overrules getOption("NMdata.run.as").

For functions that read and process data from the file system
(like NMreadCsv, NMscanData, NMscanTables and many others),
default is data.frame. Default can be overruled using
options(NMdata.run.as=...), and the default behaviour can be
overruled using the run.as argument.

For functions that process a data set supplied in an argument (as
    opposed to reading data from the file system), the class of
    the input data makes a difference. This applies to functions
    like mergeCheck, NMorderCols, findCovs, findVars, flagsAssign,
    flagsCount. If a data.table is supplied to these (and as.fun
    is NULL), a data.table will be returned. If not, a data.frame
    is still default, and the default can be configured using
    options(NMdata.run.as=...).

NMdata heavily uses data.table under the hood, so "none" means
that no conversion is done by the end of the function. Since
NMdata has no other dependencies than data.table, it cannot
convert to other classes unless the user supply the conversion
function.
}
\examples{
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"))
class(dat)
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"),
                  as.fun="none")
class(dat)
options(NMdata.run.as="none")
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"))
class(dat)
library(tibble)
dat <- NMscanData(system.file("examples/nonmem/xgxr001.lst",package="NMdata"),
                  as.fun=tibble::as_tibble)
class(dat)
}
