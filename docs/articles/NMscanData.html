<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Automated and general reader of Nonmem data • NMdata</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Automated and general reader of Nonmem data">
<meta property="og:description" content="NMdata">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">NMdata</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.5.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/NMscanData.html">Automated and general reader of Nonmem data</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="NMscanData_files/header-attrs-2.3/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Automated and general reader of Nonmem data</h1>
            
      
      
      <div class="hidden name"><code>NMscanData.Rmd</code></div>

    </div>

    
    
<p>Built 2020-09-17 using NMdata 0.0.5.1.</p>
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Getting data from R to Nonmem and back can be tedious and time consuming. The way data is exported from Nonmem means that a few tables may have to be combined, and then some variables may still be missing (like character variables which may be in the input data file). Most modellers develop some habits over time to avoid some issues. But still, it may be time demanding even for experienced modelers to pick up a model developed by someone else or by themselves earlier in their career just because they need to understand what data exported and how. This vignette focuses on how NMdata provides a very general solution for what needs to be trivial: get a dataset out of a Nonmem run. And “general” means that it will work out of the box in as many cases as possible. It will do its best to understand how the data can be read and combined, (ideally) regardless of the way the model was written.</p>
<p>In brevity, the most important steps are</p>
<ul>
<li>Read and combine output tables</li>
<li>If wanted, read input data and restore variables that were not output from the nonmem model</li>
<li>If wanted, also restore rows from input data that were disregarded in Nonmem (e.g. observations or subjects that are not part of the analysis).</li>
</ul>
<p>It should not be to hard to do. But with the large degree of flexibility Nonmem offer, there are a lot of caveats to be aware of, again especially if the model wasn’t written by your own (current) standards.</p>
</div>
<div id="get-started" class="section level2">
<h2 class="hasAnchor">
<a href="#get-started" class="anchor"></a>Get started</h2>
<p>Try NMscanData on any model:</p>
<div class="sourceCode" id="cb1"><pre class="downlit">
<span class="kw">res0</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="fu"><a href="../reference/NMdata_filepath.html">NMdata_filepath</a></span>(<span class="st">"examples/nonmem/xgxr001.lst"</span>))
<span class="co">#&gt; Number of output tables read: 1.</span>
<span class="co">#&gt; Read delimited text input data file.</span>
<span class="co">#&gt; Input data columns will be appended to output data. However, column(s) were</span>
<span class="co">#&gt; identified as unique identifiers, present in both input and output data. If this</span>
<span class="co">#&gt; column or one of these columns is not modified by the Nonmem run, consider using</span>
<span class="co">#&gt; this in col.row for a robust merge of input and output data. Candidate columns: ROW</span>
<span class="co">#&gt; To skip this check, please specify either col.row (recommended) or cbind.by.filters.</span>
<span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span>(<span class="kw">res0</span>)
<span class="co">#&gt; [1] "NMdata"     "data.table" "data.frame"</span>
</pre></div>
<p>NMscanData has read and combined input and output data and returned a data.table. The <code>NMdata</code> class allows for keeping additional information in the object, but it can be treated as a data.table. If you are not used to data.table and don’t want to use them, feel free to convert to another class, or use the <code>as.dt=FALSE</code> argument and get a data.frame back. NMdata uses data.table under the hood but all functions will work even if you don’t. In the future, NMdata may be able to return tibbles or other classes as well.</p>
<p>NMscanData writes a little information about what has been read. We are being recommended merging by a unique row identifier. The default of interpreting Nonmem code is not recommended. It is the default because it does not rely on assumptions about the input data. It happens that this dataset and one of the output tables contain a row identifier (a row counter in the column called <code>ROW</code>). Let’s follow the recommendation and use this column for merging. The following checks that we get the same result from the two methods.</p>
<div class="sourceCode" id="cb2"><pre class="downlit">
<span class="kw">res1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="fu"><a href="../reference/NMdata_filepath.html">NMdata_filepath</a></span>(<span class="st">"examples/nonmem/xgxr001.lst"</span>), 
    col.row = <span class="st">"ROW"</span>)
<span class="co">#&gt; Number of output tables read: 1.</span>
<span class="co">#&gt; Read delimited text input data file.</span>
<span class="fu"><a href="https://rdrr.io/r/base/all.equal.html">all.equal</a></span>(<span class="kw">res0</span>, <span class="kw">res1</span>)
<span class="co">#&gt; [1] TRUE</span>
</pre></div>
<p>All features shown below will work whether you supply <code>col.row</code> or not. We use <code>col.row</code> because it is more robust and always recommended.</p>
<p>Let’s have a quick look at the data we got back. The following is again done with data.table but the comments in the code should make it clear what happens.</p>
<p>The data used for the example is a PK single ascending dose data set borrowed from the xgxr package, kindly allowed by the xgxr team.</p>
<div class="sourceCode" id="cb3"><pre class="downlit">
<span class="co">## trtact is a character. Make it a factor with levels ordered</span>
<span class="co">## by numericaldose level.</span>
<span class="kw">res1</span>[, <span class="fu">`:=`</span>(<span class="kw">trtact</span>, <span class="fu"><a href="https://rdrr.io/r/stats/reorder.factor.html">reorder</a></span>(<span class="kw">trtact</span>, <span class="kw">DOSE</span>))]
<span class="co">## Derive another data.table with geometric mean pop</span>
<span class="co">## predictions by treatment and nominal sample time. Only use</span>
<span class="co">## sample records.</span>
<span class="kw">res1.mean</span> <span class="op">&lt;-</span> <span class="kw">res1</span>[<span class="kw">EVID</span> <span class="op">==</span> <span class="fl">0</span>, <span class="fu">.</span>(gmPRED = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span>(<span class="kw">PRED</span>)))), 
    by = <span class="fu">.</span>(<span class="kw">trtact</span>, <span class="kw">NOMTIME</span>)]
<span class="co">## plot individual observations and geometric mean pop</span>
<span class="co">## predictions. Split by treatment.</span>
<span class="fu">ggplot</span>(<span class="kw">res1</span>[<span class="kw">EVID</span> <span class="op">==</span> <span class="fl">0</span>]) <span class="op">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="kw">TIME</span>, <span class="kw">DV</span>)) <span class="op">+</span> <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="kw">NOMTIME</span>, 
    <span class="kw">gmPRED</span>), data = <span class="kw">res1.mean</span>, colour = <span class="st">"red"</span>) <span class="op">+</span> <span class="fu">scale_y_log10</span>() <span class="op">+</span> 
    <span class="fu">facet_wrap</span>(<span class="op">~</span><span class="kw">trtact</span>, scales = <span class="st">"free_y"</span>) <span class="op">+</span> <span class="fu">labs</span>(x = <span class="st">"Hours since administration"</span>, 
    y = <span class="st">"Concentration (ng/mL)"</span>)
</pre></div>
<p><img src="NMscanData_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>You see from the plot that the obtained dataset contains both model predictions (i.e. from output tables) and a character variable, <code>trtact</code> (i.e. from input data). NMscanData has read both and combined them.</p>
<div id="subject-level-variables" class="section level3">
<h3 class="hasAnchor">
<a href="#subject-level-variables" class="anchor"></a>Subject-level variables</h3>
<p>In a proper PK/PD analysis we need to explore the data at multiple variability levels. What we looked at above is at dosing and sampling level (one row per dosing or sampling event). NMdata provides very useful functions to extract information at other levels of variability. Before extracting the subject-level information we will add an individual exposure measure to the dataset. We will use the emperical Bayes’ estimate of the individual maximum concentration. This is derived as the maximum prediction across the sample times - it may be better to simulate the model at a richer time scale to get better precision.</p>
<div class="sourceCode" id="cb4"><pre class="downlit">
<span class="kw">res1</span>[, <span class="fu">`:=`</span>(<span class="kw">Cmax</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="kw">IPRED</span>)), by = <span class="fu">.</span>(<span class="kw">ID</span>)]
<span class="kw">res1.id</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/findCovs.html">findCovs</a></span>(<span class="kw">res1</span>, cols.id = <span class="st">"ID"</span>)
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="kw">res1.id</span>)
<span class="co">#&gt; [1] 150  27</span>
<span class="fu">ggplot</span>(<span class="kw">res1.id</span>, <span class="fu">aes</span>(<span class="kw">WEIGHTB</span>, <span class="kw">Cmax</span><span class="op">/</span><span class="kw">DOSE</span>, colour = <span class="kw">trtact</span>)) <span class="op">+</span> <span class="fu">geom_point</span>() <span class="op">+</span> 
    <span class="fu">labs</span>(x = <span class="st">"Bodyweight at baseline (kg)"</span>)
</pre></div>
<p><img src="NMscanData_files/figure-html/unnamed-chunk-6-1.png" width="672"></p>
<p>If your model includes occasion variability, you probably also want to look at</p>
<div class="sourceCode" id="cb5"><pre class="downlit">
<span class="co">## we have no occasion variability in this data res1.id.occ &lt;-</span>
<span class="co">## findCovs(res1,cols.id=c('ID','OCC'))</span>
</pre></div>
<p>Let’s use the same function to see the variables that are constant across the whole dataset</p>
<div class="sourceCode" id="cb6"><pre class="downlit">
<span class="fu"><a href="../reference/findCovs.html">findCovs</a></span>(<span class="kw">res1</span>)
<span class="co">#&gt;       TVKA  TVV2    TVCL    TVV3     TVQ      V3       Q nmout BLQ CYCLE FLAG</span>
<span class="co">#&gt; 1: 0.18116 0.042 0.72491 0.17857 8813700 0.17857 8813700  TRUE   0     1    0</span>
<span class="co">#&gt;    PART PROFDAY STUDY TIMEUNIT         flag   model</span>
<span class="co">#&gt; 1:    1       1     1    Hours Analysis set xgxr001</span>
</pre></div>
<p>Let’s take a look at what is in the <code>res1.id</code> generated above. It is a mix of variables that vary at subject level and varibles that are constant across the full dataset.</p>
<div class="sourceCode" id="cb7"><pre class="downlit">
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="kw">res1.id</span>)
<span class="co">#&gt; [1] 150  27</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span>(<span class="kw">res1.id</span>, <span class="fl">2</span>)
<span class="co">#&gt;    ID    TVKA  TVV2    TVCL    TVV3     TVQ      KA    V2      CL      V3</span>
<span class="co">#&gt; 1: 31 0.18116 0.042 0.72491 0.17857 8813700 0.18116 0.042 0.72491 0.17857</span>
<span class="co">#&gt; 2: 32 0.18116 0.042 0.72491 0.17857 8813700 0.18116 0.042 0.72491 0.17857</span>
<span class="co">#&gt;          Q nmout BLQ CYCLE DOSE FLAG PART PROFDAY STUDY WEIGHTB   eff0 TIMEUNIT</span>
<span class="co">#&gt; 1: 8813700  TRUE   0     1    3    0    1       1     1  87.031 56.461    Hours</span>
<span class="co">#&gt; 2: 8813700  TRUE   0     1    3    0    1       1     1 100.620 45.096    Hours</span>
<span class="co">#&gt;    TRTACT         flag trtact   model Cmax</span>
<span class="co">#&gt; 1:   3 mg Analysis set   3 mg xgxr001    0</span>
<span class="co">#&gt; 2:   3 mg Analysis set   3 mg xgxr001    0</span>
</pre></div>
<p><code>findCovs</code> has a counterpart in <code>findVars</code> which finds variables that do vary within constant values of optional columns. To get only the ones that vary within the dataset (i.e. they are truely subject-level variables), we can do</p>
<div class="sourceCode" id="cb8"><pre class="downlit">
<span class="kw">res1.id2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/findVars.html">findVars</a></span>(<span class="kw">res1.id</span>)
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span>(<span class="kw">res1.id2</span>)
<span class="co">#&gt; [1] 150  10</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span>(<span class="kw">res1.id2</span>, <span class="fl">2</span>)
<span class="co">#&gt;    ID      KA    V2      CL DOSE WEIGHTB   eff0 TRTACT trtact Cmax</span>
<span class="co">#&gt; 1: 31 0.18116 0.042 0.72491    3  87.031 56.461   3 mg   3 mg    0</span>
<span class="co">#&gt; 2: 32 0.18116 0.042 0.72491    3 100.620 45.096   3 mg   3 mg    0</span>
</pre></div>
<p><code>findVars</code> supports the cols.id argument too. So you can use <code><a href="../reference/findVars.html">findVars(res1,cols.id="ID")</a></code> for find variables that are non-constant within (at least one value of) ID. <code>cols.id</code> can be of arbitrary length.</p>
<p>Of course, we most often know what covariates or other subject-level variables to look at, and we would not search for them after running a nonmem model. But in the situation where you are looking at someone else’s work or you are doing a meta analysis across models where the data has been coded slightly differently, these simple tools can be very useful. Also, remember that if a variable is returned by these functions, you know that they fullfill the variability requirement. We know that variables in <code>res1.id</code> above non-varying within ID, meaning that no ID has more than one value of the variable. <code>NA</code> counts as any other value, so if a value is returned for subject in res1.id, this subject does not have NA’s in <code>res1</code>.</p>
</div>
</div>
<div id="more-options-and-features" class="section level2">
<h2 class="hasAnchor">
<a href="#more-options-and-features" class="anchor"></a>More options and features</h2>
<div id="recover-rows" class="section level3">
<h3 class="hasAnchor">
<a href="#recover-rows" class="anchor"></a>Recover rows</h3>
<p>You may have wondered why there is so little data on the small doses in the plot of observations and geometric mean population predictions above. The reason is that observations below the lower limit of quantification have been disregarded. For this and many other reasons, it is very common to use <code>ACCEPT</code> and <code>IGNORE</code> statements in the <code>$INPUT</code> section of nonmem control streams. NMscanData can include this data in the returned data object as well. Let’s redo the plot above taking advantage of this option:</p>
<div class="sourceCode" id="cb9"><pre class="downlit">
<span class="kw">res2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="fu"><a href="../reference/NMdata_filepath.html">NMdata_filepath</a></span>(<span class="st">"examples/nonmem/xgxr014.lst"</span>), 
    col.row = <span class="st">"ROW"</span>, recover.rows = <span class="fl">TRUE</span>)
<span class="co">#&gt; Number of output tables read: 1.</span>
<span class="co">#&gt; Read rds input data file.</span>
<span class="co">## Derive another data.table with geometric mean pop</span>
<span class="co">## predictions by treatment and nominal sample time. Only use</span>
<span class="co">## sample records.</span>
<span class="kw">res2.mean</span> <span class="op">&lt;-</span> <span class="kw">res2</span>[<span class="kw">EVID</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;</span> <span class="kw">nmout</span> <span class="op">==</span> <span class="fl">TRUE</span>, <span class="fu">.</span>(gmPRED = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span>(<span class="kw">PRED</span>)))), 
    by = <span class="fu">.</span>(<span class="kw">trtact</span>, <span class="kw">NOMTIME</span>)]
<span class="co">## plot individual observations and geometric mean pop</span>
<span class="co">## predictions. Split by treatment.</span>
<span class="fu">ggplot</span>(<span class="kw">res2</span>[<span class="kw">EVID</span> <span class="op">==</span> <span class="fl">0</span>]) <span class="op">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="kw">TIME</span>, <span class="kw">DV</span>, colour = <span class="kw">flag</span>)) <span class="op">+</span> 
    <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="kw">NOMTIME</span>, <span class="kw">gmPRED</span>), data = <span class="kw">res2.mean</span>) <span class="op">+</span> <span class="fu">scale_y_log10</span>() <span class="op">+</span> 
    <span class="fu">facet_wrap</span>(<span class="op">~</span><span class="kw">trtact</span>, scales = <span class="st">"free_y"</span>) <span class="op">+</span> <span class="fu">labs</span>(x = <span class="st">"Hours since administration"</span>, 
    y = <span class="st">"Concentration (ng/mL)"</span>)
</pre></div>
<p><img src="NMscanData_files/figure-html/unnamed-chunk-11-1.png" width="672"></p>
<p>A couple of details are different compared to when we read <code>res1</code>. For now, notice one thing changed when calculating the population geometric means by nominal time and dose. We included <code>nmout==TRUE</code>. <code>nmout</code> is a boolean column created by NMscanData expressing whether the rows were in the output data (<code>nmout==TRUE</code>) or they were recovered from the input data. <code>PRED</code> is obviously not calculated for data rows neglected by Nonmem, so we want to keep those out of the calculation. Let’s see how many were recovered</p>
<div class="sourceCode" id="cb10"><pre class="downlit">
<span class="co">## this is just a long-format representation of</span>
<span class="co">## with(res1,table(nmout,flag)) using data.table.</span>
<span class="kw">res1</span>[, <span class="kw">.N</span>, by = <span class="fu">.</span>(<span class="kw">nmout</span>, <span class="kw">flag</span>)]
<span class="co">#&gt;    nmout         flag   N</span>
<span class="co">#&gt; 1:  TRUE Analysis set 905</span>
</pre></div>
<p>So 905 were part of the analysis.</p>
<p>The <code>recover.rows</code> argument can be used independently of whether <code>col.row</code> is used.</p>
</div>
<div id="combine-multiple-models" class="section level3">
<h3 class="hasAnchor">
<a href="#combine-multiple-models" class="anchor"></a>Combine multiple models</h3>
<p>You may have noticed a column called <code>model</code> in some of the output above. NMscanData by default adds this column for convenience when working with multiple models. You can specify both column name and content as arguments in NMscanData. If you don’t, the column will be called <code>model</code>, and the model name taken from the lst file name (say, <code>xgxr001</code>). In the following we use this to compare population predictions from two different models. We read them again just to show the use of the argument to name the models ourselves.</p>
<div class="sourceCode" id="cb11"><pre class="downlit">
<span class="co">## notice fill is an option to rbind with data.table</span>
<span class="kw">res1.m</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="fu"><a href="../reference/NMdata_filepath.html">NMdata_filepath</a></span>(<span class="st">"examples/nonmem/xgxr001.lst"</span>), 
    col.row = <span class="st">"ROW"</span>)
<span class="co">#&gt; Number of output tables read: 1.</span>
<span class="co">#&gt; Read delimited text input data file.</span>
<span class="kw">res2.m</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="fu"><a href="../reference/NMdata_filepath.html">NMdata_filepath</a></span>(<span class="st">"examples/nonmem/xgxr014.lst"</span>), 
    col.row = <span class="st">"ROW"</span>, name = <span class="st">"single-compartment"</span>)
<span class="co">#&gt; Number of output tables read: 1.</span>
<span class="co">#&gt; Read rds input data file.</span>
<span class="kw">res.mult</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span>(<span class="kw">res1.m</span>, <span class="kw">res2.m</span>, fill = <span class="kw">T</span>)
<span class="kw">res.mult.mean</span> <span class="op">&lt;-</span> <span class="kw">res.mult</span>[<span class="kw">EVID</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;</span> <span class="kw">nmout</span> <span class="op">==</span> <span class="fl">TRUE</span>, <span class="fu">.</span>(gmPRED = <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span>(<span class="kw">PRED</span>)))), 
    by = <span class="fu">.</span>(<span class="kw">model</span>, <span class="kw">trtact</span>, <span class="kw">NOMTIME</span>)]

<span class="fu">ggplot</span>(<span class="kw">res.mult.mean</span>, <span class="fu">aes</span>(<span class="kw">NOMTIME</span>, <span class="kw">gmPRED</span>, colour = <span class="kw">model</span>)) <span class="op">+</span> 
    <span class="fu">geom_line</span>() <span class="op">+</span> <span class="fu">scale_y_log10</span>() <span class="op">+</span> <span class="fu">facet_wrap</span>(<span class="op">~</span><span class="kw">trtact</span>, scales = <span class="st">"free_y"</span>)
</pre></div>
<p><img src="NMscanData_files/figure-html/unnamed-chunk-13-1.png" width="672"></p>
</div>
<div id="use-a-row-identifier-or-interpret-nonmem-code" class="section level3">
<h3 class="hasAnchor">
<a href="#use-a-row-identifier-or-interpret-nonmem-code" class="anchor"></a>Use a row identifier or interpret Nonmem code</h3>
<p>A unique row identifier is not needed for NMscanData to run and in most cases succesfully and correctly complete all the steps above. However, the most robust way to use NMscanData is to include a unique row identifier in both input and at least one full-length output table. Then tell NMscanData to use the row identifier using the <code>col.row</code> argument. The advantage is that less nonmem code has to be interpreted for this method. However, notice that no checks are being done if the row identifier has been modified during the nonmem run. If you tell NMscanData that the column called <code>ROW</code> is a to be used as the row identifier, and ROW is being modified in say <code>$PK</code> before being output in an output table, this will mess up the result. But if you keep the good practice of including a unique row identifier in your dataset, the advice is to include it in at least one output table and tell NMscanData to use it by the argument <code>col.row</code>.</p>
</div>
<div id="preserve-all-input-data-properties" class="section level3">
<h3 class="hasAnchor">
<a href="#preserve-all-input-data-properties" class="anchor"></a>Preserve all input data properties</h3>
<p>In the code above when plotting the population predictions together with individual observations, we saw that character variables (the treatment as dose with unit) was read from the input data file and was used for splitting the plots. However, in order to sort the plots naturally by increasing dose level, we had to run <code>reorder</code> on the variable. This is because the input data is read from a csv file. NMscanData will not code any character variables as factors when reading from text files.</p>
<p>Since the character representation of treatment was already prepared, it would be natural to encode the factor levels already at that point. In order to preserve such information, we can use R’s native rds format. If the argument <code>use.rds</code> is <code>TRUE</code>, NMscanData will look for an rds file next to the input data file (which is a delimited text file) the exact same name as the text file except the extension must be “.rds” rather than say “.csv” (for nonmem and NMscanData, the extension of the delimited text file doesn’t matter). If it finds the rds file, this will be used instead. No checks are done of whether the contents are similar in any way to the delimited text file which is ignored in this case.</p>
<p>Return to the example above creating the dataset <code>dat2</code>. Notice the message from NMscanData that an rds file was found. This is why we could sort the plots correctly on the dose level with reordering the factor levels first. There are three advantages of using rds files</p>
<ul>
<li>All attributes are kept. This includes column classes and factor levels.</li>
<li>Reading speed may be improved (NMdata uses <code>fread</code> from <code>data.table</code> which is extremely fast for delimited files so in many cases this difference can be small).</li>
<li>File sizes are greatly reduced from text to rds. This can be a big advantage if you are transfering files or reading over a network connection. NMdata is generally very fast (thanks to <code>data.table</code>) so file access (I/O) is likely to be the main bottleneck.</li>
</ul>
<p>If you write Nonmem datasets with the <code><a href="../reference/NMwriteData.html">NMdata::NMwriteData</a></code>, you can get an rds file automatically, exactly where <code>NMscanData</code> will look for it. Creating datasets are out of the scope of this vignette, though.</p>
</div>
<div id="custom-naming-of-input-and-output-control-streams" class="section level3">
<h3 class="hasAnchor">
<a href="#custom-naming-of-input-and-output-control-streams" class="anchor"></a>Custom naming of input and output control streams</h3>
<p>By default, NMscanData expects a psn-style naming of input and output control streams. This means that if the input control stream is called model.mod, the returned control stream is called model.lst. If you use a different setup, you can use the <code>file.mod</code> argument. Do one of the following if needed:</p>
<ul>
<li>Explicitly give the path to the input control stream or</li>
<li>Pass a function that translates from the output control stream to the input. Example if the input is called <code>input.txt</code> and the output is called <code>output.txt</code>:</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="downlit">
<span class="kw">out2in</span> <span class="op">&lt;-</span> <span class="fu">function</span>(<span class="kw">file</span>) <span class="fu"><a href="https://rdrr.io/r/base/file.path.html">file.path</a></span>(<span class="fu"><a href="https://rdrr.io/r/base/basename.html">dirname</a></span>(<span class="kw">file</span>), <span class="st">"input.txt"</span>)
<span class="kw">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NMscanData.html">NMscanData</a></span>(<span class="st">"path/to/output.txt"</span>, file.mod = <span class="kw">out2in</span>)
</pre></div>
</div>
</div>
<div id="what-exactly-will-nmscandata-return" class="section level2">
<h2 class="hasAnchor">
<a href="#what-exactly-will-nmscandata-return" class="anchor"></a>What exactly will NMscanData return?</h2>
<p>So far, the merge has been very straightforward, but in many situations, choices have to be made.</p>
<p>The following main principles are followed</p>
<ul>
<li>Output data prevails over input data</li>
<li>Row-specific output data is preferred over ID-level (FIRSTONLY or LASTONLY) tables</li>
<li>Output tables are prioritized by their order of apperance</li>
<li>Input data is as defined in the $INPUT section in Nonmem. This includes renaming of columns, and columns that are dropped in Nonmem (DROP or SKIP) are disregarded. Columns that are not read by Nonmem are named as in the input data file.</li>
<li>If rows are being recovered from input data (the <code>recover.rows</code> argument), no information from output is merged onto these rows</li>
<li>The primary aim is to return the output data. If input and output cannot be meaningfully combined (very rare), output will be returned.</li>
</ul>
</div>
<div id="the-building-blocks" class="section level2">
<h2 class="hasAnchor">
<a href="#the-building-blocks" class="anchor"></a>The building blocks</h2>
<p>The lst file was scanned for output tables, and they were all read (including interpreting the possible firstonly option). The input data has been used based on the DATA and INPUT sections of the control stream. The key steps in this process are available as independent functions.</p>
<ul>
<li><p>NMreadTab: Read an Nonmem output table based on the path to the output table file.</p></li>
<li><p>NMscanTables: Read all output data files defined in a Nonmem run. Return a list of tables (as data.frames or data.tables).</p></li>
<li><p>NMtransInput: Read input data based on a nonmem file. Data will be processed and named like the Nonmem model. ACCEPT and IGNORE filters can be applied as well. There are a few limitations to this functionality at this point.</p></li>
</ul>
</div>
<div id="what-should-i-do-for-my-models-to-be-compatible-with-nmscandata" class="section level2">
<h2 class="hasAnchor">
<a href="#what-should-i-do-for-my-models-to-be-compatible-with-nmscandata" class="anchor"></a>What should I do for my models to be compatible with NMscanData?</h2>
<p>The answer to this should be as close to “nothing” as possible - that’s more or less the aim of the function. You just have to make sure that the information that you need is present in input data and output data. No need to output information that is unchanged from input, but make sure to output what you need (like IPRED, CWRES, CL, ETA1 etc which cannot be found in input). Some of these values can be found from other files generated by Nonmem but notice: NMscanData uses only input and output data.</p>
<p>It is recommended to always use a unique row identifier in both input and output data. This is the most robust way to merge back with input data. In firstonly tables, include the subject ID. Again, everything will most likely work even if you don’t, I personally don’t like relying on “most likely” when I can just as well have robustness.</p>
</div>
<div id="limitations" class="section level2">
<h2 class="hasAnchor">
<a href="#limitations" class="anchor"></a>Limitations</h2>
<div id="input-file-must-exist-and-be-unmodified-since-model-run" class="section level3">
<h3 class="hasAnchor">
<a href="#input-file-must-exist-and-be-unmodified-since-model-run" class="anchor"></a>Input file must exist and be unmodified since model run</h3>
<p>If merging with input data, the input data must be available as was when the model was run. If you want to avoid this potential issue, Nonmem can be run in a wrapper script that either copies the input data, or runs NMscanData and saves the output in a compressed file format (like rds or zip).</p>
</div>
<div id="not-all-data-filter-statements-implemented" class="section level3">
<h3 class="hasAnchor">
<a href="#not-all-data-filter-statements-implemented" class="anchor"></a>Not all data filter statements implemented</h3>
<p>Nested ACCEPT and IGNORE statements are not supported at this point. The resulting number of rows after applying filters is checked against row-level output table dimensions (if any available). In other words, you have to be unlucky to run into trouble without an error. But it is alway recommended to use a unique row identifier in both input and output tables in order to avoid relying on interpretation of Nonmem code.</p>
</div>
<div id="character-time-variables-not-interpreted" class="section level3">
<h3 class="hasAnchor">
<a href="#character-time-variables-not-interpreted" class="anchor"></a>Character time variables not interpreted</h3>
<p>Nonmem supports a clocktime input format for TIME. Based on a day counter and a character (“00:00”) clock format, Nonmem can calculate the individual time since first record. This behaviour is not mimicked by NMscanData, and the only ways to get TIME in this case are to either include it in an output TABLE or to code the translation yourself after calling NMscanData. Of course, this is on the todo list.</p>
</div>
<div id="firstlastonly-not-supported" class="section level3">
<h3 class="hasAnchor">
<a href="#firstlastonly-not-supported" class="anchor"></a>FIRSTLASTONLY not supported</h3>
<p>The <code>FIRSTLASTONLY</code> option in <code>$TABLE</code> results in two rows per subject. For now, this cannot be merged with input, and these tables are disregarded with a warning (you can read them with <code>NMscanTables</code>). <code>LASTONLY</code> is treated like <code>FIRSTONLY</code>, i.e. as ID-level information if not available elsewhere.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Philip Delff.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
